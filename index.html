<!DOCTYPE HTML>
<html>
<head>
	<title>STEALTH 'em UP</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			origin_marker-color: #000000;
		}

		#help{
			position: absolute;
			z-index: 20;
			color: black;
			top: 20px;
			left: 120px;
		}
	</style>

	<script src="../../bin/pixi.dev.js"></script>
	
</head>
<body>
    
    <script src="js/jo_debug.js"></script>
    <script src="js/jo_math.js"></script>
	<script src="js/jo_sprite.js"></script>
	<script src="js/jo_cam.js"></script>
	<script src="js/jo_utility.js"></script>
	<script src="js/jo_wall.js"></script>
	<script src="js/jo_grid.js"></script>
	<script src="js/astar.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/jo_raycast.js"></script>
	<script src="js/jo_security_camera.js"></script>
	<script src="js/sprite_hero.js"></script>
	<script src="js/sprite_guard.js"></script>
    <script>
    
    
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    /*
Window Setup
    */
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    
    //Mr Doob's Stats.js:
    var stats = new Stats();
    
    var window_properties = {width: 620*2, height: 400*2};
    var mouse, hero_aim;
    var keys = {w: false, a: false, s: false, d: false, shift: false, space:false};
	// create an new instance of a pixi stage
	// the second parameter is interactivity...
	var interactive = true;
	var stage = new PIXI.Stage(0xEEEEEE, interactive);
	// create a renderer instance.
	var renderer = PIXI.autoDetectRenderer(window_properties.width, window_properties.height);
	// add the renderer view element to the DOM
	document.body.appendChild(renderer.view);
	requestAnimFrame(animate);

    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    /*
Map / Game Object Setup
    */
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////    
    
    //grid/map
    var grid = new jo_grid(map_diamond_store);
    stage.addChild(tile_container);
    
    //camera/debug
    var camera = new jo_cam(window_properties);
    var hero_line = new debug_line();
    var test_cone = new debug_line();
    var hero_cir = new debug_circle();
    
    //UI text.  Use newMessage() to add a message.
    var message = new PIXI.Text("", { font: "20px Arial", fill: "#000000", align: "left", stroke: "#FFFFFF", strokeThickness: 4 });
    message.position.x = 0;
    message.position.y = window_properties.height;
    message.anchor.y = 1;
    var messageText = [];
    stage.addChild(message);

    //images:
    var img_orange = PIXI.Texture.fromImage("orange2.png");
    var img_blue = PIXI.Texture.fromImage("blue.png");
    var img_masked = PIXI.Texture.fromImage("masked.png");
    var img_skull = PIXI.Texture.fromImage("skull.png");
    var img_guard_alert = PIXI.Texture.fromImage("alert_guard.png");
    var img_security_camera = PIXI.Texture.fromImage("camera.png");
    var img_security_camera_alerted = PIXI.Texture.fromImage("camera_alert.png");
    var img_computer = PIXI.Texture.fromImage("computer.png");
    var img_computer_off = PIXI.Texture.fromImage("computer_off.png");
    var img_money = PIXI.Texture.fromImage("money.png");
    var img_getawaycar = PIXI.Texture.fromImage("van.png");
    var img_hero_with_money = PIXI.Texture.fromImage("blue_with_money.png");
    
    

    
    //make sprites
    var hero = new sprite_hero_wrapper(new PIXI.Sprite(img_blue));
    var hero_end_aim_coord;
    hero.x = 1182;
    hero.y = 615;
    hero.speed = 4;
    var hero_drag_target = null; // a special var reserved for when the hero is dragging something.
    var guards = [];
    guards.push(new sprite_guard_wrapper(new PIXI.Sprite(img_orange)));
    guards.push(new sprite_guard_wrapper(new PIXI.Sprite(img_orange)));
    guards.push(new sprite_guard_wrapper(new PIXI.Sprite(img_orange)));
    guards[0].x = 288;
    guards[0].y = 96;
    guards[1].x = 480;
    guards[1].y = 96;
    guards[2].x = 608;
    guards[2].y = 96;
    
    var computer_for_security_cameras = new jo_sprite(new PIXI.Sprite(img_computer));
    computer_for_security_cameras.x = 480;
    computer_for_security_cameras.y = 1056;
    
    //security camera
    var security_cameras = [];
    security_cameras.push(new security_camera_wrapper(new PIXI.Sprite(img_security_camera),193,129,Math.PI/2,0));
    security_cameras.push(new security_camera_wrapper(new PIXI.Sprite(img_security_camera),193,1153,Math.PI,0));
    
    var alarmingObjects = [];//guards will sound alarm if they see an alarming object (dead bodies)

    
    //Loot and Getaway car:
	var getawaycar = new jo_sprite(new PIXI.Sprite(img_getawaycar));
    getawaycar.sprite.anchor.y = 0.25;
    getawaycar.x = 1184;
    getawaycar.y = 384;
    getawaycar.rad = -Math.PI/2;
    var loot = [];
	var money = new jo_sprite(new PIXI.Sprite(img_money));
    money.x = 480;
    money.y = 288;
    loot.push(money);
    money = new jo_sprite(new PIXI.Sprite(img_money));
    money.x = 540;
    money.y = 224;
    loot.push(money);
    money = new jo_sprite(new PIXI.Sprite(img_money));
    money.x = 672;
    money.y = 288;
    loot.push(money);
    money = new jo_sprite(new PIXI.Sprite(img_money));
    money.x = 928;
    money.y = 288;
    loot.push(money);
    
  
    
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    /*
Game Loop
    */
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    
    function gameloop(){
        
        
        //////////////////////
        //update Mouse
        //////////////////////
        mouse_rel = stage.getMousePosition();//gets relative mouse position
        mouse = camera.objectivePoint(mouse_rel);
        
        
        //////////////////////
        //Hero Movement and Aim
        //////////////////////
        
        //get raycast for hero aim:
        hero_end_aim_coord = getRaycastPoint(hero.x,hero.y,mouse.x,mouse.y);
        
        //update hero directions based on keys:
        if(keys.w){
            hero.target.y = hero.y - 100;
        }else if(keys.s){
            hero.target.y = hero.y + 100;
        }else hero.target.y = hero.y;
        if(keys.d){
            hero.target.x = hero.x + 100;
        }else if(keys.a){
            hero.target.x = hero.x - 100;
        }else hero.target.x = hero.x;
     
     
        
        //////////////////////
        //update all sprites:
        //////////////////////
        
        
        
        //////////////////////
        //update Hero
        //////////////////////
        
        hero_aim = new Ray(hero.x,hero.y,hero_end_aim_coord.x,hero_end_aim_coord.y);
        if(hero.masked)hero_line.draw_Ray(hero_aim);//only draw aim line when hero is masked (which means gun is out).
        hero.move_to_target();
        //check collisions and prepare to draw walls:
        for(var i = 0; i < grid.cells.length; i++){
            if(grid.cells[i].solid){
                hero.collide(grid.cells[i].v2);
                hero.collide(grid.cells[i].v4);
                hero.collide(grid.cells[i].v6);
                hero.collide(grid.cells[i].v8);
                hero.collide_with_wall_sides(grid.cells[i]);
            }
            
            //draw:
            //grid.cells[i].draw();//debug
            grid.cells[i].prepare_for_draw();
        }
        hero.prepare_for_draw();
        
        if(hero_drag_target)hero.sprite.rotation += Math.PI;//reverse the hero's rotation because he is dragging something.
        
        
        //////////////////////
        //update Guards
        //////////////////////
        
        for(var i = 0; i < guards.length; i++){
            if(guards[i].alive){
                //if guard are not already alarmed
                if(!guards[i].alarmed){
                    //check if guard sees alarming objects:
                    for(var j = 0; j < alarmingObjects.length; j++){
                        if(guards[i].doesSpriteSeeSprite(alarmingObjects[j])){
                            newMessage('A guard has seen something alarming!');
                            guards[i].becomeAlarmed(alarmingObjects[j]);
                        }
                    }
                    //check if guard sees hero:
                    if(guards[i].doesSpriteSeeSprite(hero)){
                        if(hero.masked){
                            newMessage('A guard has seen you wearing a mask!');
                            //alarm if hero is seen masked
                            guards[i].becomeAlarmed(hero);
                        }else if(grid.isTileRestricted_coords(hero.x,hero.y)){
                            newMessage('A guard has seen you in a restricted area!');
                            //alarm if hero is seen on restricted tiles
                            guards[i].becomeAlarmed(hero);
                        }
                        
                    }
                }
                //if guard has a path
                if(guards[i].path.length > 0){
                    //if guard does not have a target:
                    if(guards[i].target.x == null || guards[i].target.y == null){
                        guards[i].target = guards[i].path.shift();//get the first element.
                    }
                    
                }else{
                    //if guard does not have a path:
                    guards[i].getRandomPatrolPath();
                }
                //call move to target, if target is reached, it will return true and set target to null
                if(guards[i].move_to_target()){
                    guards[i].target.x = null;
                    guards[i].target.y = null;
                }
            }
            guards[i].prepare_for_draw();
        }
        
        //////////////////////
        //Security Cameras
        //////////////////////
        for(var i = 0; i < security_cameras.length; i++){
            
            if(!cameras_disabled && security_cameras[i].alive){
                security_cameras[i].swivel();
                
                
                //if guards are not already alarmed
                if(!security_cameras[i].alarmed){
                    //check if security_cameras[i] sees alarming objects:
                    for(var j = 0; j < alarmingObjects.length; j++){
                        if(security_cameras[i].doesSpriteSeeSprite(alarmingObjects[j])){
                            newMessage('A security camera has seen something alarming!');
                            security_cameras[i].becomeAlarmed(alarmingObjects[j]);
                        }
                    }
                    //check if security_camera sees hero:
                    if(security_cameras[i].doesSpriteSeeSprite(hero)){
                        //alarm if hero is seen masked
                        if(hero.masked){
                            newMessage('A security camera has seen you wearing a mask!');
                            security_cameras[i].becomeAlarmed(hero);
                        }else if(grid.isTileRestricted_coords(hero.x,hero.y)){
                            //alarm if hero is seen on restricted tiles
                            newMessage('A security camera has seen you in a restricted area!');
                            security_cameras[i].becomeAlarmed(hero);
                        }
                    }
                }
            }
            security_cameras[i].prepare_for_draw();
        }
        
        computer_for_security_cameras.prepare_for_draw();
        
        
        //////////////////////
        //Getaway Car and Loot
        //////////////////////
        getawaycar.prepare_for_draw();
        for(var i = 0; i < loot.length; i++){
            loot[i].prepare_for_draw();
        }

        
        //////////////////////
        //Drag Target
        //////////////////////
        
        //move sprite/item which the hero is dragging.
        if(hero_drag_target){
            hero_drag_target.target = hero;//the drag target is "following" the hero.
            hero_drag_target.get_dragged();
            //hero_drag_target.prepare_for_draw();//not necessary - should already be prepared in another line of code
        }
        
        
        //////////////////////
        //Camera
        //////////////////////
        
        //loose camera
        camera.x = hero.x + (mouse.x - hero.x)/3;
        camera.y = hero.y + (mouse.y - hero.y)/3;
        /*The below commented block is for smooth camera
        //press space to look around
        if(keys['space']){
            //camera floats between hero and mouse
            //smooth camera
            camera.following = true;
            camera.target = {x: hero.x + (mouse.x - hero.x)/2, y: hero.y + (mouse.y - hero.y)/2};
        }else{
            //set camera target to hero
            if(camera.following){
                //return to hero
                camera.target = hero;
            }else{
                //stick to hero
                camera.x = hero.x; 
                camera.y = hero.y;
            }
        }
        //if the camera is set to following, move it to target, otherwise, don't because it is sticking to target.
        if(camera.following && camera.move_to_target()){
            if(camera.target == hero){
                camera.following = false;//when camera reaches it's target, turn off following so it can just stick.
            }
        }*/
        
        

    }

	function animate() {
        stats.begin();//Mr Doob's Stats.js
        
        gameloop();
	    // render the stage
	    renderer.render(stage);

	    requestAnimFrame(animate);	
        
        
        stats.end();//Mr Doob's Stats.js
        
    
        
	}
    
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    /*
Key Handlers
    */
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////

    window.onkeydown = function(e){
        var code = e.keyCode ? e.keyCode : e.which;
        //keyinfo[code] = String.fromCharCode(code);
        if(code == 87){keys['w'] = true;}
        if(code == 65){keys['a'] = true;}
        if(code == 83){keys['s'] = true;}
        if(code == 68){keys['d'] = true;}
        if(code == 16){
            keys['shift'] = true;
            if(!hero.carry){
                //hero cannot remove mask while carrying loot
                hero.masked = !hero.masked;//toggle mask
                //change image to reflect that hero is wearing mask
                if(hero.masked){
                    hero.sprite.setTexture(img_masked);
                }
                else{
                    hero_line.clear();//clear red aim line
                    hero.sprite.setTexture(img_blue);
                }
            }
        }
        if(code == 32){
            keys['space'] = true;
            if(hero_drag_target){
                //drag is a toggle action so release current drag target.
                hero_drag_target = null;
                //bring hero speed back to normal
                hero.speed = hero.speed*2;
            }else{
                //check if any dead guards are close enough to be dragged.
                for(var i = 0; i < guards.length; i++){
                    if(get_distance(hero.x,hero.y,guards[i].x,guards[i].y) <= hero.radius*2.5){
                        if(!guards[i].alive){
                            //hero is dragging a dead body
                            
                            //slow down hero speed because he just started dragging something.
                            hero.speed = hero.speed/2;
                            hero_drag_target = guards[i];
                            hero_drag_target.speed = hero.speed;
                            hero_drag_target.stop_distance = hero.radius*2;//I don't know why but the stop distance here seems to need to be bigger by a factor of 10
                            return;
                        }else if(hero.masked && !guards[i].alarmed){
                            //hero is choking out a live guard who is not already alarmed:
                            
                            //I'm going to use a trick here: make the guard dead so he can be dragged but replace his image back to a person until he chokes out, then back to a body
                            guards[i].kill();
                            guards[i].sprite.setTexture(img_orange);
                            
                            //slow down hero speed because he just started dragging something.
                            hero.speed = hero.speed/2;
                            hero_drag_target = guards[i];
                            hero_drag_target.speed = hero.speed;
                            hero_drag_target.stop_distance = hero.radius*2;//I don't know why but the stop distance here seems to need to be bigger by a factor of 10
                            setTimeout(function(){
                                this.sprite.setTexture(img_skull);
                            }.bind(guards[i]), 3000);
                            return;
                        }

                    }
                    
                        
                    
                }
                //note: dragging guards takes precedence over all the following actions.
                
                //check if hero is close enough to the security camera computer to disable cameras:
                if(get_distance(hero.x,hero.y,computer_for_security_cameras.x,computer_for_security_cameras .y) <= hero.radius*4){
                    cameras_disabled = true;
                    newMessage('All security cameras have been disabled!');
                    computer_for_security_cameras.sprite.setTexture(img_computer_off);
                }
                if(hero.masked){
                    //hero must be masked to interact with loot
                    if(!hero.carry){
                        //check if hero is close enough to the loot to pick it up
                        for(var i = 0; i < loot.length; i++){
                            if(get_distance(hero.x,hero.y,loot[i].x,loot[i] .y) <= hero.radius*2){
                                hero.carry = loot[i];
                                loot[i].sprite.visible = false;
                                hero.sprite.setTexture(img_hero_with_money);
                                newMessage("You've got the money!  Get it to the escape vehicle!");
                            }
                        }
                    }else{
                        //hero is already carring loot, drop it
                        hero.carry.sprite.visible = true;
                        hero.carry.x = hero.x;
                        hero.carry.y = hero.y;
                        hero.carry = null;
                        hero.sprite.setTexture(img_masked);
                    }
                }
            }
            
        }
        
    };
    window.onkeyup = function(e){
        var code = e.keyCode ? e.keyCode : e.which;
        if(code == 87){keys['w'] = false;}
        if(code == 65){keys['a'] = false;}
        if(code == 83){keys['s'] = false;}
        if(code == 68){keys['d'] = false;}
        if(code == 16){keys['shift'] = false;}
        if(code == 32){keys['space'] = false;}
        
    };
    onmousedown = function(e){
        //you can only shoot if hero is masked
        if(hero.masked){
            //shoot_gun();//make noise which draws guards
            mouse_click_obj = camera.objectivePoint(e);  //uses e's .x and .y to find objective click
            
            //what happens on mouse click:
            
            
            //check if hero aim intersects guard:
            for(var i = 0; i < guards.length; i++){
                if(circle_linesetment_intersect(guards[i].getCircleInfoForUtilityLib(),hero_aim.start,hero_aim.end)){
                    guards[i].kill();

                }
            
            }
            //check if hero aim intersects camera:
            for(var i = 0; i < security_cameras.length; i++){
                if(circle_linesetment_intersect(security_cameras[i].getCircleInfoForUtilityLib(),hero_aim.start,hero_aim.end)){
                    security_cameras[i].kill();
                }
            
            }
        }
    
    }
    
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    /*
Other
    */
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    function newMessage(mess){
        messageText.push(mess);
        setTimeout(function(){
            messageText.shift();
            updateMessage();
        },7000);
        updateMessage();
    }
    function updateMessage(){
        var textForMessage = "";
        for(var i = 0; i < messageText.length; i++){
            textForMessage += messageText[i] + "\n";
        }
        message.setText(textForMessage);
    };
    function alert_all_guards(){
        for(var z = 0; z < guards.length; z++){
            //alert the other living guards
            if(guards[z].alive)guards[z].hearAlarm();
        }
    }
    function shoot_gun(){
        //makes a sound and draws all guards:
        for(var i = 0; i < guards.length; i++){
            guards[i].hearAlarm();
            var hero_index = grid.getIndexFromCoords_2d(hero.x,hero.y);
            var guard_index = grid.getIndexFromCoords_2d(guards[i].x,guards[i].y);
            var path = grid.getPath(guard_index,hero_index);
            guards[i].path = path;
        }
    }
    //Mr. Doob's Stats.js
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.body.appendChild( stats.domElement );
    

	</script>
	</body>
</html>
