var map_diamond_store = {
    "data":[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 2, 1, 1, 2, 1, 4, 1, 4, 1, 1, 1, 1, 1, 1, 4, 1, 4, 1, 1, 1, 2, 1, 1, 2, 1, 4, 1, 4, 4, 4, 4, 1, 4, 4, 4, 1, 4, 4, 4, 1, 2, 1, 1, 2, 1, 4, 1, 4, 4, 4, 3, 1, 4, 4, 4, 1, 4, 4, 4, 1, 2, 1, 1, 2, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 3, 3, 2, 3, 3, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 3, 3, 2, 3, 2, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 1, 1, 2, 1, 2, 3, 3, 2, 3, 2, 1, 1, 2, 3, 2, 3, 3, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 3, 3, 2, 3, 3, 2, 2, 3, 3, 2, 3, 3, 2, 1, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 1, 2, 1, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 2, 2, 2, 1, 2, 1, 1, 2, 1, 4, 1, 4, 4, 3, 3, 3, 4, 4, 4, 4, 2, 2, 1, 1, 2, 1, 1, 2, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    "height":20,
    "width":20
    };
var map1 = {
        "data":[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        "height":20,
        "width":20
        };

var img_tile_black = PIXI.Texture.fromImage("tile_black.png");
var img_tile_white = PIXI.Texture.fromImage("tile_white.png");
var img_tile_brown = PIXI.Texture.fromImage("tile_brown.png");
var img_tile_red = PIXI.Texture.fromImage("tile_red.png");

var tile_container = new PIXI.SpriteBatch();//for efficiency!

function jo_grid(map){
    //2d array:
    this.width = map.width;
    this.height = map.height;
    this.cell_size = 64

    //this is the map, fill it will walls!
    this.map_data = map.data;
    
    this.cells = [];
    
    this.getInfoFromIndex = function(index){
        //gets the 2d index from the 1d index
        var x_index = index%this.width;
        var y_index = Math.floor(index/this.width);
        return {x_index: x_index, y_index: y_index};
    };
    
    this.getCellFromIndex = function(row, col){
        //gets 1d index from 2d index
        //NOTE: I had to reverse col and row, usually the formula is width * row + col, but
        //because of the way that the 2d array works I had to reverse it.
        return this.cells[this.width * col + row];
    };
    
    this.getIndexFromCoords_2d = function(x,y){
        //returns the index of the cell that coords are within
        var indexX = Math.floor(x/this.cell_size);
        var indexY = Math.floor(y/this.cell_size);
        return {x: indexX, y: indexY};
    }
    this.isWallSightBlocking_coords = function(x,y){
        //used for ray casting
        //returns true if the wall that the (x,y) coords are within blocks vision:
        
        //return if coords are outside of map bounds:
        if(x < 0 || y < 0)return false;//do not accept negative values;
        if(x > this.cell_size*this.width || y > this.cell_size*this.height)return false;//coord out of bounds
        var grid_index = this.getIndexFromCoords_2d(x,y);
        var cell = this.getCellFromIndex(grid_index.x,grid_index.y);
        
        if(cell && cell.blocks_vision){
            //cell.image_sprite.setTexture(img_tile_brown);Turns cell green for debug so I can see which cell the coords are in.
            return true;
        }
        else return false;
        
    }
    this.isWallSolid_coords = function(x,y){
        //returns true if the wall that the (x,y) coords are within is solid:
        
        //return if coords are outside of map bounds:
        if(x < 0 || y < 0)return false;//do not accept negative values;
        if(x > this.cell_size*this.width || y > this.cell_size*this.height)return false;//coord out of bounds
        var grid_index = this.getIndexFromCoords_2d(x,y);
        var cell = this.getCellFromIndex(grid_index.x,grid_index.y);
        
        if(cell && cell.solid){
            //cell.image_sprite.setTexture(img_tile_brown);Turns cell green for debug so I can see which cell the coords are in.
            return true;
        }
        else return false;
        
    }
    this.isTileRestricted_coords = function(x,y){
        //returns true if the wall that the (x,y) coords are within is restricted:
        
        //return if coords are outside of map bounds:
        if(x < 0 || y < 0)return false;//do not accept negative values;
        if(x > this.cell_size*this.width || y > this.cell_size*this.height)return false;//coord out of bounds
        var grid_index = this.getIndexFromCoords_2d(x,y);
        var cell = this.getCellFromIndex(grid_index.x,grid_index.y);
        
        if(cell && cell.restricted){
            //cell.image_sprite.setTexture(img_tile_brown);Turns cell green for debug so I can see which cell the coords are in.
            return true;
        }
        else return false;
        
    }
    this.getWallCoords = function(wall_type,x_index,y_index){
        //returns the objective coordinates of a wall based on its type and index.
        //this should work even for non-square walls.
        
        //the type simply specifies where the position of the vertices will be, it does not correlate, necessarily, with the image in that cell.
        
        var startx = x_index*this.cell_size;
        var starty = y_index*this.cell_size;
        switch(wall_type){
            case 'square':
                //square
                return [{x:startx,y:starty},{x:startx+this.cell_size,y:starty},{x:startx+this.cell_size,y:starty+this.cell_size},{x:startx,y:starty+this.cell_size}];
                break;
            default:
                //square
                return [{x:startx,y:starty},{x:startx+this.cell_size,y:starty},{x:startx+this.cell_size,y:starty+this.cell_size},{x:startx,y:starty+this.cell_size}];
                break;
        }
    
    };
    //used for random patrol paths:
    this.getRandomNonSolidCellIndex = function(){
    
        var cell;
        var randomCellIndex;
        do{
            //random number between                           max           and  min
            randomCellIndex = Math.floor(Math.random() * this.cells.length) + 0;
            cell = this.cells[randomCellIndex];
        
        }while(cell.solid);
        return randomCellIndex;
    
    }
    
    //create map:
    for(var i = 0; i < this.map_data.length; i++){
        var tile_type = this.map_data[i];
        var info = this.getInfoFromIndex(i);
        var x_index = info.x_index;
        var y_index = info.y_index;
        switch(tile_type) {
        case 1:
            //black
            this.cells.push(new jo_wall(img_tile_black,true,true,false,this.getWallCoords('square',x_index,y_index)));
            break;
        case 2:
            //white
            this.cells.push(new jo_wall(img_tile_white,false,false,false,this.getWallCoords('square',x_index,y_index)));
            break;
        case 3:
            //green
            this.cells.push(new jo_wall(img_tile_brown,true,false,false,this.getWallCoords('square',x_index,y_index)));
            break;
        case 4:
            //red
            this.cells.push(new jo_wall(img_tile_red,false,false,true,this.getWallCoords('square',x_index,y_index)));
            break;
        default:
            this.cells.push(new jo_wall(img_tile_white,false,false,this.getWallCoords('square',x_index,y_index)));
            break;
        };
    }
    delete this.map_data;
    
    /////////////////////////////
    ////////////A STAR///////////
    /////////////////////////////
    
    this.cells_astar = [];//astar.js requires an actual 2d array so this variable will be made from cells as a 2D array
    //the below for loop turns this.cells into a 2d array and puts it in this.cells_astar
    for(var i = 0; i < this.height; i++){
        var slice = this.cells.slice(i*this.width,i*this.width+this.width);
        for(var j = 0; j < slice.length; j++){
            //convert tile codes into 0 for wall and 1 for floor:
            if(slice[j].solid){
                slice[j] = 0;
            }else{
                slice[j] = 1;
            }
        }
        //console.log('map ' , i , ' ' , slice);
        this.cells_astar.push(slice);
    }
    this.cells_astar = new Graph(this.cells_astar);//convert to astar graph
    this.getPath = function(start,end){
        //start/end in format {x: #,y: #} # representing cell indices.
        //because of how I read 2d arrays I have to treat all the y's as x's and all the x's as y's in the astar lib
        //                      y   x
        var start = this.cells_astar.nodes[start.y][start.x];//remember x and y are switched for the astar lib
        var end = this.cells_astar.nodes[end.y][end.x];//remember x and y are switched for the astar lib
        var result = astar.search(this.cells_astar.nodes, start, end);
        var path = [];
        for(var i = 0; i < result.length; i++){
            path.push({x: result[i].y*this.cell_size+this.cell_size/2, y: result[i].x*this.cell_size+this.cell_size/2});//return path in obj pixel location, index*64-32 will center the pixel on the correct index cell
            //console.log(result[i].y , ',' , result[i].x);
        }
        return path; //path is an array of points
    
    }
        


}